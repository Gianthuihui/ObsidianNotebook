<!DOCTYPE html> <html><head>
		<title>MEGA多序列比对及建树（NJ）</title>
		<base href="..\../">
		<meta id="root-path" root-path="..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="长脑子了 - MEGA多序列比对及建树（NJ）">
		<meta property="og:title" content="MEGA多序列比对及建树（NJ）">
		<meta property="og:description" content="长脑子了 - MEGA多序列比对及建树（NJ）">
		<meta property="og:type" content="website">
		<meta property="og:url" content="软件操作/分析原理/mega多序列比对及建树（nj）.html">
		<meta property="og:image" content="https://pic2.zhimg.com/v2-d9b0f011dc2aef918cb58db521087cf5_b.jpg">
		<meta property="og:site_name" content="长脑子了">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block;text-align:left}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mn{display:inline-block;text-align:left}mjx-texatom{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c39::before{padding:.666em .5em .022em 0;content:"9"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c2013::before{padding:.285em .5em 0 0;content:"–"}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-cD7::before{padding:.491em .778em 0 0;content:"×"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}mjx-c.mjx-c2F::before{padding:.75em .5em .25em 0;content:"/"}mjx-c.mjx-c36::before{padding:.666em .5em .022em 0;content:"6"}</style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="MEGA多序列比对及建树（NJ）"><p dir="auto">MEGA多序列比对及建树（NJ）</p></h1><div><p dir="auto">作者：水瓶之翼<br>
链接：<a rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/643415592" target="_blank">https://zhuanlan.zhihu.com/p/643415592</a><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  </p></div><div class="heading-wrapper"><h3 data-heading="**3.1 导入待比对的 fasta 序列**" dir="auto" class="heading" id="**3.1_导入待比对的_fasta_序列**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>3.1 导入待比对的 fasta 序列</strong></h3><div class="heading-children"><div><p dir="auto">依次点击：ALIGN -&gt; Edit/Build Alignment -&gt; Retrieve a sequence from a file -&gt; OK -&gt; 选择我们前面整理好的fasta文件 -&gt; 出现 Alignment Explorer 窗口</p></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-d9b0f011dc2aef918cb58db521087cf5_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">​导入序列后如下图所示：（这时如果还想更改某条序列的名称可以在该原名字处右键选中 Edit Sequence Name编辑）</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-f6716951662a3abced450ccbb1b53068_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">​导入后我们还是可以检查一下序列，这时候如果存在两端有多余碱基的序列，可以很容易检查发现。在MEGA中可以进行序列裁剪、更改、反向互补等操作。如果我们没有进行步骤2.3的检查，导入MEGA后再检查也是一样的，序列的方向是其中最重要的一点，不能与其它序列反向。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**3.2 多序列比对**" dir="auto" class="heading" id="**3.2_多序列比对**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>3.2 多序列比对</strong></h3><div class="heading-children"><div><p dir="auto">MEGA提供了两种序列比对方法，Clustal W 与 MUSCLE ，有文献报道 MUSCLE 的准确性更高，且速度比Clustal W 更快，因此这里我们直接使用 MUSCLE 进行多序列比对。</p></div><div><p dir="auto">按<code>Ctrl</code> + <code>A</code>选中所有序列 -&gt; 点击 Alignment -&gt; 选择 Align by MUSCLE -&gt; 参数设置界面直接点击 OK 即可，一般不需要更改参数。（如果用Clustal W 进行核酸序列比对的话一般也不需要修改参数）</p></div><div><p dir="auto"><strong>比对后结果</strong>：</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-4d2a7d1f7513bfc4d48c333d7c85166c_b.jpg" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**3.3 保存比对结果**" dir="auto" class="heading" id="**3.3_保存比对结果**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>3.3 保存比对结果</strong></h3><div class="heading-children"><div><p dir="auto">依次点击 Data -&gt; Export Alignment -&gt; MEGA Format，然后保存为<code>.meg</code>格式的文件即可（保存时会提示输入标题以及是否是编码序列），我这里命名为<code>example.meg</code>。<strong>另外</strong>我们这里也可以另外保存一份 FASTA格式的文件用于我们最后一步的可视化（我这里命名为<code>example.fas</code>）。</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-62936c7b694b99e186b7b831782a4c88_b.jpg" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**3.4 比对结果可靠性检验**" dir="auto" class="heading" id="**3.4_比对结果可靠性检验**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>3.4 比对结果可靠性检验</strong></h3><div class="heading-children"><div><ol>
<li data-line="0" dir="auto">
<p><strong>首先</strong>，我们可以大致看一下有没有<strong>异常序列</strong>，如果发现比对后存在明显与其它序列不同的序列，可以用MEGA进行相应编辑或者考虑删除后重新比对。  </p>
</li>
<li data-line="2" dir="auto">
<p><strong>其次可以检验比对结果的可靠性。</strong><br>
<strong>如果比对结果不可靠，那么构建的进化树也会不可靠</strong>。Thompson等人（1999）的一项研究比较了一些比对程序，表明当配对比对中氨基酸一致性(identity)的平均百分比太低时，多重比对的准确性低于它们能够产生可靠的系统发育树的水平。</p>
<p>Thompson的研究表明，当<strong>氨基酸</strong>平均identity&lt;20%时，则&lt;50%的残基是被正确比对的。在20%-30% identity 之间的“过渡带”中，约80%的残基正确对齐，<strong>&gt;30%的identity</strong>中，<strong>90%的残基正确比对</strong>。  </p>
<p>因此我们可以通过计算序列之间的 <strong>p距离</strong>(<strong>p-distance</strong>)来检验核酸或氨基酸比对的可靠性。比如在氨基酸比对中， p-distance 值为 0.6，代表氨基酸平均 identity为 1-0.6=40%，如前所述，<strong>氨基酸的identity一般需要&gt;30%</strong>，才比较可信(<strong>即 p-distance&lt;0.7</strong>)，因此当 p-distance=0.6时，我们可以认为氨基酸的比对结果是比较可靠的。<br>
对于<strong>核酸</strong>来说，检验方法类似，假如 p-distance 为 0.33，则 67% 的 identity 就可能不足以 用于准确估计进化关系。<strong>p-distance&lt;0.33一般时认为结果比较可靠</strong>。  </p>
<p>一般来说，假如核酸序列或者氨基酸序列的 p-distance 较高时，不应将多序列比对的结果用 于构建进化树，而是应该<strong>删除其中不可靠的序列重新比对</strong>，使得<strong>核酸序列或者氨基酸序列的 p-distance 满足 核酸：&lt;0.33/氨基酸：&lt;0.7</strong>。  </p>
</li>
</ol></div><div><ul>
<li data-line="0" dir="auto">在 MEGA 中依次点击：DISTANCE -&gt; Compute Overall Mean Distance -&gt; 选择前面导出的比对完的 <code>.meg</code> 文件：</li>
</ul></div><div><p dir="auto"><img src="https://pic4.zhimg.com/v2-6a7f792592f2bd33193938a6abe622e7_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">然后按照下图进行参数设置：</li>
</ul></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-22fb0e35700c42198bf480cef7814bdd_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">点击OK后，可以得到 1 个平均 p-distance，本例中是0.26&lt;0.33，因此我们可以认为本次比对结果比较可靠。</li>
</ul></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-87b6596c66c4d7143109533cd0f506d8_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><strong>总结：</strong></p></div><div><p dir="auto">比对方法以及比对可靠性的检验方法有很多种，上面只是介绍了其中一种。比如 MAFFT、PRANK等比对方法就被认为准确性比较高，有文献报道 MAFFT准确性比Clustal W高、速度也更快，PRANK准确性被认为比MAFFT与Clustal W都高，但速度却相对较慢。大家在实际比对时可以尝试多种方法，并在准确性与速度方面进行一定的权衡。</p></div></div></div><div class="heading-wrapper"><h2 data-heading="**4. 构建进化树**" dir="auto" class="heading" id="**4._构建进化树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4. 构建进化树</strong></h2><div class="heading-children"><div><p dir="auto"><strong>构建进化树的方法</strong>主要可以分为两类：</p></div><div><p dir="auto"><strong>一是基于距离的方法</strong>，基于所计算出的序列间遗传距离来构建进化树，快速，会产生单一的树。</p></div><div><ul>
<li data-line="0" dir="auto">邻接法：Neihbor Jioning(NJ)</li>
<li data-line="1" dir="auto">非加权分组平均法(UPGMA)</li>
</ul></div><div><p dir="auto"><strong>二是基于字符的方法</strong>，基于描述遗传字符演化的数学模型构建进化树，速度较慢，会产生多棵树，然后根据其最优选择标准来找出最佳进化树。</p></div><div><ul>
<li data-line="0" dir="auto">最大简约法(Maximum Parsimony,MP)</li>
<li data-line="1" dir="auto">最大似然法(Maximum Likelihood,ML)</li>
<li data-line="2" dir="auto">贝叶斯马尔科夫链蒙特卡洛法(BMCMC)</li>
</ul></div><div><p dir="auto">根据《phylogenetic trees made easy》作者所述，MEGA是构建NJ树最好的程序，且其强烈反对使用UPGMA法构建系统发育树。</p></div><div class="heading-wrapper"><h3 data-heading="**4.1 构建 NJ 树**" dir="auto" class="heading" id="**4.1_构建_NJ_树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.1 构建 NJ 树</strong></h3><div class="heading-children"><div><p dir="auto">邻接法：Neihbor Jioning(NJ)是使用得最广泛的一种方法。我们使用MEGA根据前面的比对结果构建NJ树。</p></div><div><p dir="auto"><strong>邻接法基本介绍：</strong></p></div><div><p dir="auto">邻接法是一种基于最小进化原理的算法，基于距离矩阵构建树，它不检验所有可能的拓扑结构，能同时给出拓扑结构和分支长度。它的优点是重建的树相对准确，假设少，计算速度快，只得到一棵树。</p></div><div><p dir="auto">NJ树<strong>适用于进化距离较小、信息位点较少的短序列</strong>，<strong>可用于大型数据集</strong>（速度很快）。其<strong>缺点主要表现在将序列上的所有位点等同对待，所分析序列的进化距离不能太大</strong>（对于距离过远的序列会出现<strong>长枝吸引</strong>现象）。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.1.1 检验是否适合构建NJ树**" dir="auto" class="heading" id="**4.1.1_检验是否适合构建NJ树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.1.1 检验是否适合构建NJ树</strong></h3><div class="heading-children"><div><p dir="auto"><strong>假如 Jukes-Cantor(JC)距离 &gt;1.0，则序列不适合构建NJ树，而应采用其它方法</strong>。</p></div><div><p dir="auto">我们采用与 3.4 相同的步骤，在 MEGA 中依次点击：DISTANCE -&gt; Compute Overall Mean Distance -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件，然后在参数设置中将 Model/Method 改为 Jukes-Cantor 即可计算出 JC 距离。</p></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-0f7d4eb99e71f743bdad5316fe5ad8f1_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">在本例中计算出的 JC 距离为 0.34，因此适合构建 NJ 树。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.1.2 NJ 树的估计-理论**" dir="auto" class="heading" id="**4.1.2_NJ_树的估计-理论**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.1.2 NJ 树的估计-理论</strong></h3><div class="heading-children"><div><blockquote dir="auto">
<p>为什么说是估计，类似于模型构建，因为事实上我们永远无法得到真实的物种演化的系统发育树，我们所谓的构建进化树只是在用各种算法尝试得到最接近真实进化树的一颗树。</p>
</blockquote></div><div><p dir="auto">我们估计进化树时一般会估计多次。</p></div><div><ul>
<li data-line="0" dir="auto">首先是在<strong>没有 Bootstrap</strong> 的情况下先估计得到一颗树，初步查看<strong>是否有明显异常的序列</strong>被分类到某个子树中（关于什么是 Bootstrap 后面会介绍）。</li>
<li data-line="1" dir="auto">如果<strong>有</strong>这种情况应对<strong>序列进行检查</strong>，必要时还需要<strong>删除</strong>某些序列，然后<strong>重新进行多序列比对</strong>，再重新估计树。</li>
<li data-line="2" dir="auto">当我们认为树中<strong>没有</strong>异常序列时，再<strong>设置 Bootstrap 值（一般为1000以上，至少100）</strong>，估计最终的树。</li>
</ul></div><div><p dir="auto">对于<strong>最大似然法</strong>，这样估计树可以<strong>节约很多时间</strong>，因为最大似然法设置 Bootstrap 后速度会非常慢，对于 <strong>NJ 法</strong>，在序列不多的情况下（只有数百条），可以<strong>直接设置 Bootstrap</strong>，因为 NJ 法速度很快。</p></div><div><p dir="auto">在 MEGA中依次点击：PHYLOGENY -&gt; Construct/Test Neighbor Joining Tree -&gt; 设置参数，我们先看一下参数设计界面的各个参数。</p></div><div><p dir="auto"><img src="https://pic4.zhimg.com/v2-75b2e04f62513fc770aeb5fa8980abb3_b.jpg" referrerpolicy="no-referrer"></p></div><div><hr></div><div><p dir="auto">估计 NJ 树时各参数的意义与设置：</p></div><div><ul>
<li data-line="0" dir="auto"><strong>Test of Phylogeny</strong>：进化树的<strong>检验设置</strong>，我们可以根据前面说的设置为None，表明不检验（速度快），也可以设置为 Bootstrap method，然后在下面的 No.of Bootstrap Replications 设置检验次数，关于 Bootstrap 的介绍可见后面备注3。</li>
<li data-line="1" dir="auto"><strong>Substitutions Type</strong>：本文只介绍比对核酸<strong>序列</strong>构建进化树，因此直接选择默认的 Nucleotide。</li>
<li data-line="2" dir="auto"><strong>Model/Method</strong>：选择<strong>进化模型</strong>。我们这里选择 Maximum Composite Likelihood，算法原理在后面备注1中介绍。</li>
<li data-line="3" dir="auto"><strong>Substitution to include</strong>：选择哪些<strong>替代类型</strong>用于计算，一般不需要改。transition 代表转换，嘌呤之间或者嘧啶之间，如 A&lt;-&gt;G,C&lt;-&gt;T；transversion 颠换，嘌呤与嘧啶之间，如A&lt;-&gt;C/T,G&lt;-&gt;C/T</li>
<li data-line="4" dir="auto"><strong>Rates among Sites</strong> ：位点之间的<strong>替换率分布</strong>。我们这里选择Gamma Distributed (<strong>G</strong>)，在 Gamma Parmamter中填的参数值可以<strong>通过MEGA计算</strong>得到。关于 Rates 的介绍可见后面备注2</li>
<li data-line="5" dir="auto"><strong>Patterns among Lineages</strong>：默认即可，我们一般比对的都是<strong>同源序列</strong>。</li>
<li data-line="6" dir="auto"><strong>Gaps/Missing Data Treatment</strong>：该参数设置如何<strong>处理空格</strong>(gaps)。几乎完全由空格组成的位点对估计树中的分支顺序或分支长度的贡献很小，但它们确实增加了计算时间。<strong>Complete deletion</strong>，代表直接删除所有包含gap的位点。<strong>Pairwise deletion</strong>代表配对删除，从而使缺少数据的位点仅在需要时被删除而不是总被删除。<strong>Partial deletion</strong>代表部分删除，当 Site Coverage Cutoff设置为95%时，代表如果有95%的序列在此位点上是空格，则将该位点删除。</li>
<li data-line="7" dir="auto"><strong>Select Condon Positions</strong>: 代表选择密码子的哪些位点来构建树，<strong>通常全选</strong>。除非你有特殊的需求，如只想根据密码子的第三位碱基构建进化树。</li>
<li data-line="8" dir="auto"><strong>Number of threads</strong>：代表分析时电脑的线程数设置，根据自己的电脑情况可<strong>随意设置</strong>。</li>
</ul></div><div><hr></div><div><p dir="auto"><strong>备注1 进化模型</strong></p></div><div><p dir="auto">在祖先序列进化为子序列的过程中，如果<strong>仅仅计算两个核苷酸之间的距离是不够的</strong>，比如某个位点由 A 替换成了 T，我们假设计算出的它们之间的距离时是0.5，然而我们无法知道这中间是否发生了其它变化，比如可能先由 A 替换成 G，接着再从 G 替换成 T，这与 A 直接替换成 T 的替换率显然是不同的。又或者某个位点未发生替换，我们计算出的它们的距离0，然而它中间也有可能经过了其它替换，比如A-&gt;G-&gt;A。因此我们<strong>需要选择进化模型来试图解释这些替换，以更准确地估计序列进化的过程</strong>。</p></div><div><p dir="auto"><strong>一、单参数模型</strong></p></div><div><ul>
<li data-line="0" dir="auto">Jukes-Cantor model(JC)：该模型认为任何<strong>核苷酸改变为其它核苷酸的几率是相等的</strong>，只需要知道核苷酸替换率即可，因此称为 one-parameter model 或者 Jukes-Cantor model</li>
<li data-line="1" dir="auto">Felsenstein 81 (F81)模型拓展了 Jukes-Cantor model，允许碱基替换的<strong>基础替换率不同</strong>。</li>
</ul></div><div><p dir="auto">在单参数模型中，碱基替换率可以通过下图矩阵表示，称之为Q矩阵，<strong>只有一种核酸替换率 α</strong>。  </p></div><div><p dir="auto"><img src="https://pic4.zhimg.com/v2-5b16f604e254b53f407075fe1778908b_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><strong>二、其它模型</strong>  </p></div><div><p dir="auto">然而每种核苷酸的突变几率往往是不一样的。</p></div><div><ul>
<li data-line="0" dir="auto"><strong>Kimura 2-parameter model</strong>(K2P) 拓展了Jukes-Cantor model，考虑<strong>核苷酸转换和颠换的替换率不一样</strong>。K2P模型假设Q矩阵中有<strong>两种替换率，转换一种，颠换一种</strong>。<br>
因此，K2P的Q矩阵如下，<strong>转换的替换率为α，颠换的替换率为b</strong><br>
</li>
</ul></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-a969c184712839e585771be6b7b80548_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">Tamura 3-parameter model 添加了对成分偏差的修正，如果基础比率与相同频率有很大差异，可能是由于突变偏差，那么就需要考虑这种差异<br>
</li>
<li data-line="2" dir="auto">Tamura-Nei model 延伸了前一个模型，把嘌呤之间的的转换和嘧啶之间的颠换的替换率进行了区分。<br>
</li>
<li data-line="4" dir="auto">Felsenstein 84 (F84) model 和 HKY model也基于类似 Tamura-Nei model的假设<br>
</li>
<li data-line="6" dir="auto"><strong>Maximum Composite Likelihood model</strong> 是一种基于似然性的 Tamura-Nei model的应用，提高了计算配对距离(pairse distance)的精确度<br>
</li>
<li data-line="8" dir="auto">General Time-Reversible(GTR) model。该模型假设 Q矩阵有6种不同的率，认为碱基不同方向的替换概率相同(即A-&gt;C与C-&gt;A的替换率相同)。<br>
</li>
</ul></div><div><p dir="auto"><strong>总的来说</strong>，<strong>Kimura 2-parameter 与 Maximum Composite Likelihood</strong> 模型是目前<strong>构建NJ树</strong>时文献中<strong>用得比较多的模型</strong>。</p></div><div><hr></div><div><p dir="auto"><strong>备注2 位点之间的替换率</strong></p></div><div><p dir="auto">前面的进化模型中所说的<strong>碱基替换率</strong>指的是某个位点的碱基替换为其它碱基的频率（考察的是<strong>单个位点</strong>的碱基替换），<strong>这些模型假设所有位点的碱基替换率都是一样的</strong>，但<strong>实际上，不同位点的替换率可能会不同</strong>，比如编码序列的起始密码子处，通常为ATG（有时也为GTG），因此我们可以推测起始密码子处2，3位点的碱基替换率是0。</p></div><div><p dir="auto">因此引入了序列中估计不同位点之间替换率的方法。</p></div><div><ul>
<li data-line="0" dir="auto"><strong>Uniform Rates</strong> 假设<strong>不同位点之间的碱基替换率是相同的</strong>。</li>
<li data-line="1" dir="auto">还有一种假设是<strong>不同位点的碱基替换率的分布存在一种普遍的模式</strong>，常用的分布是伽马分布(<strong>Gamma distribution</strong>)，我们可以使用MEGA预测Gamma分布的参数。</li>
</ul></div><div><hr></div><div><p dir="auto"><strong>备注3 进化树的可靠性检验</strong></p></div><div><p dir="auto">前面也已经提过，事实上我们估计的所有树都是错误的，只是通过<strong>模型算法尽量找到一颗最接近真实的树</strong>。因此我们<strong>需要一种方法来评估通过这些模型构建出来的树的可靠性</strong>。其中 Bootstrap 方法是使用得最广泛的一种，<strong>NJ、ML等方法都使用 Bootstrap 检验进化树的可靠性</strong>，不过 <strong>BMCMC 通过进化枝后验概率计算树的可靠性</strong>。</p></div><div><p dir="auto"><strong>需要注意</strong>的是 Bootstrap 评估的是我们估计树的<strong>可重现性</strong>，而非树的准确性。</p></div><div><p dir="auto">下面介绍 bootstrap 的<strong>原理与过程</strong>。</p></div><div><ul>
<li data-line="0" dir="auto">首先，我们把<strong>未经过Bootstrap</strong>第一次估计出的树称为<strong>原始树</strong>，比如以下面的比对结果构建出一颗原始树：</li>
</ul></div><div><p dir="auto"><img src="https://pic4.zhimg.com/v2-c5d0e5e27e00b50a737ab9314fa37a9b_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">上面的比对结果中包括10个碱基位点，5条序列。在<strong>第1次 bootstrap</strong> 时，<strong>会重新构建1个包含10个位点的比对结果</strong>，<strong>首先</strong>从10个位点中随机选取1个位点的序列作为伪比对第1个位点的碱基，<strong>接着</strong>重新从上面10个位点的序列中选取1个位点的序列作为伪比对第2个位点的碱基，如此直到形成一个新的包含10个位点的伪比对结果。<strong>这样</strong>得到的伪比对结果与原比对结果的不同在于有些位点可能会重复（<strong>有放回抽样</strong>），比如说<strong>第1次 bootstrap得到下面的伪比对结果</strong>，然后<strong>基于这个伪比对结果用相同的模型与参数估计一颗新的树</strong>：</li>
</ul></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-70808113aed10860bae1845346029aac_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">接着按照<strong>相同的方式</strong>进行第2次、第3次…<strong>直到第1000次 bootstrap</strong>。最后会得到一颗<strong>最终的树</strong>，该树的<strong>每个节点旁</strong>都会记录一个<strong>自展值(Bootstrap value)</strong>。假如物种A的自展值为90，代表在1000次bootstrap中，有900次物种A在进化树中都被归为某一类(clade)，剩下的100次物种A被归类到别的clade。一般认为<strong>自展值&gt;70的估计出来的分支是比较可靠的</strong>。</li>
</ul></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.1.3 NJ 树的估计-实践**" dir="auto" class="heading" id="**4.1.3_NJ_树的估计-实践**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.1.3 NJ 树的估计-实践</strong></h3><div class="heading-children"><div><p dir="auto"><strong>一、估计 gamma 参数</strong><br>
按照前面的理论知识，<strong>如果我们认为自己的序列在不同位点具有不同的碱基替换率</strong>，可以设置gamma分布，所以<strong>先用MEGA得到gamma分布的参数</strong>：<br>
依次点击：RATES -&gt; Gamma Parameter for Site Rates (ML) -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件，不用更改参数，点击 OK即可  </p></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-6cde7e208e5111bb8cb4525831b5224d_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">在结果页面，我们可以得到一个 gamma 分布的参数为 0.499 ：</p></div><div><p dir="auto"><img src="https://pic4.zhimg.com/v2-a207544a5691a0785c77e00dbd79f8cf_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><strong>二、估计 NJ 进化树</strong><br>
在 MEGA中依次点击：PHYLOGENY -&gt; Construct/Test Neighbor Joining Tree -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件 -&gt; 设置参数。根据前面的理论知识，我们按照下图设置参数，接着点击OK即开始估计进化树。  </p></div><div><p dir="auto"><img src="https://pic4.zhimg.com/v2-75b2e04f62513fc770aeb5fa8980abb3_b.jpg" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.1.4 树的认识与MEGA中的可视化**" dir="auto" class="heading" id="**4.1.4_树的认识与MEGA中的可视化**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.1.4 树的认识与MEGA中的可视化</strong></h3><div class="heading-children"><div><p dir="auto"><strong>一、进化树的基本结构</strong></p></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-843f1cabff313b5975643f90e9ff75b5_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">外部节点(<strong>绿色</strong>圆点)又被称为“<strong>叶节点</strong>”，表示采样及测序的<strong>实际生物体</strong>(例如，传染病研究中的病毒)，在进化生物学术语中又被称为“<strong>分类单元(taxa)</strong>”。</li>
<li data-line="1" dir="auto">内部节点(<strong>蓝色</strong>圆点)表示外部节点的<strong>假设祖先</strong>。</li>
<li data-line="2" dir="auto">根(<strong>红色</strong>圆点) 是进化树中<strong>所有物种的共同祖先</strong>。</li>
<li data-line="3" dir="auto"><strong>水平线条</strong>表示<strong>树的分支</strong>，又表示生物所发生的<strong>以时间或遗传分歧衡量的演变</strong>(灰色<strong>数字</strong>)。</li>
<li data-line="4" dir="auto"><strong>底部的线条</strong>表示这些分支长度的<strong>标尺</strong>。</li>
</ul></div><div><p dir="auto"><strong>二、MEGA中的进化树查看</strong></p></div><div><ul>
<li data-line="0" dir="auto">本例中 MEGA 得到的进化树如下图1，先看红色框，这块区域显示了<strong>树的拓扑结构</strong>，与前一个图中稍有不同的是，在内部节点旁边还出现了1个数值（<strong>红色箭头</strong>所示），这是因为我们因为设置了 <strong>Bootstrap</strong>，<strong>该数值即表示自展值</strong>。可以看得现在的进化树是比较拥挤的，因为枝长按照实际计算出的值被画了出来，这样可以<strong>显示生物体演变的实际程度</strong>，此时树下方会有枝长的标尺。<br>
</li>
<li data-line="2" dir="auto">蓝色框中是 MEGA 中绘制进化树的图形化界面选项，我们可以根据自己的需求定制不同风格的进化树，比如我们<strong>只想看一下各个分类单元的分类情况</strong>，可以点击蓝色框中 Layout -&gt; Toggle Scaling of the Tree（粉红色箭头），就可以<strong>隐藏枝长的实际值</strong>（如下方第2张图所示），此时<strong>分支的长度不代表实际意义</strong>。<br>
</li>
<li data-line="4" dir="auto">又比如我们前面提到<strong>自展值过小的得到的分支一般不是很可靠</strong>，我们也可以通过蓝色框中的 Compute -&gt; 设置自展值 Cutoff 值为50，则会<strong>合并自展值小于50的分支</strong>（如下方第3张图所示）。<br>
</li>
<li data-line="6" dir="auto">另外我们还可以在蓝色框中设置是否显示自展值、枝长、显示为环形进化树、设置clade、提取子树等，只需要点击即可实时显示效果。<br>
</li>
<li data-line="8" dir="auto">另外在绿色方框中会有两个树，<strong>Bootstrap Consensus Tree</strong>可以让我们更好地<strong>看清自展值与对应的节点</strong>，不过我们<strong>后续进化树可视化一般使用Original Tree</strong> 即可。<br>
</li>
</ul></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-f56d152978c5ebe4e3504c8cb9d2dadc_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-837baafab0bc174a39d1b1bfad15189c_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-5ca8f984f1f783c1c0ba953ec0f46986_b.jpg" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.1.5 绘制有根树**" dir="auto" class="heading" id="**4.1.5_绘制有根树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.1.5 绘制有根树</strong></h3><div class="heading-children"><div><p dir="auto"><strong>关于无根树与有根树</strong></p></div><div><p dir="auto"><strong>我们构建的树</strong>（包括其它方法如<strong>ML法、MP法</strong>等）<strong>基本上得到的都是无根树</strong>。</p></div><div><ul>
<li data-line="0" dir="auto"><strong>无根树没有方向性</strong>可言，能从一个节点追溯其父节点也可以追溯其子节点，如果移除无根树的某个分支，可以拆分到不同的分组，这些不同的分组称为 <strong>splits</strong>。</li>
<li data-line="1" dir="auto"><strong>有根树有方向性</strong>，不能从一个节点追溯其父节点，<strong>只能追溯其子节点</strong>，因为物种进化是有方向的，如果移除有根树的某个分支，得到的分组称为 <strong>clades</strong>。</li>
</ul></div><div><p dir="auto">虽然得到的是无根树，但是 MEGA 绘制出来的进化树看起来容易让人认为是有根树。我们在进化分析时往往希望得到的是有根树，因为只有有根树才能分析物种的演化关系。因此有时候通常会通过无根树人为绘制有根树。<strong>在一堆同源性较高的序列中去寻找它们的根往往不容易，因此我们往往需要借助额外的信息，常用的方法是借助外群(outgroup</strong>)。</p></div><div><p dir="auto"><strong>外群</strong>(outgroup)可以被定义为1条或多条序列，这些序列与内群(ingroup)序列的进化距离比内群序列之间的距离都要远。</p></div><div><hr></div><div><p dir="auto">在前面的例子中，我选了18条 PRRSV 病毒的 ORF5 基因的序列，要绘制有根树，我需要另外加入1条外群序列，我选择的是与 PRRSV 病毒在同一个科下的另一种病毒的 ORF5 基因序列。在重新进行多序列比对、进化树估计后，得到下方的进化树，红框中的序列为新加入的外群序列，可以发现其与前面的18条序列相比形成了单独的一个分支：</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-500d32c96dc00a882476e3eec43a18e0_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">接下来绘制有根树，首先在图中鼠标左键<strong>点击外群所在的分支</strong>，然后鼠标右键<strong>选择 Root tree</strong> 即可（如下图1所示），接着我们得到了1颗有根树（如下图2所示）。</p></div><div><p dir="auto">虽然我们<strong>绘制的有根树看起来和无根树没什么区别，但实际上已经设置了1个根节点</strong>（下方图2中<strong>绿色箭头</strong>所示），而且仔细观察可以发现两颗树的<strong>分支长度发生了变化</strong>。</p></div><div><ul>
<li data-line="0" dir="auto">上图<strong>无根树</strong>的分支看起来有两个分支分成了外群与内群，但实际上只有1个分支，其实际分支长度为这两个长度之和，MEGA中将其绘制成了看起来有两个分支的图形。</li>
<li data-line="1" dir="auto">下图2的<strong>有根树</strong>的分支确实存在两个分支，将其分成了内群与外群，因此分支长度也发生了改变。</li>
</ul></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-22a75561afb6854a302f79089a37754c_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-124ff5bed50cb7a14a67b5fa9322875a_b.jpg" referrerpolicy="no-referrer"></p></div><div><hr></div><div><p dir="auto">接着我们就可以根据这个<strong>有根树添加不同的 clade</strong> 了。首先点击某个类别所有分类单元所在的共同分支（下图红色箭头），然后依次选择 Subtree -&gt; Draw Options -&gt; Format Subtree，即可进入设置 clade 的界面。（如果要删除设置的某个clade，还是这样选择，会出现一个Clear clade或者Clear All subtree options的选项，代表清楚某个分类或者清楚所有分类设置）</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-ca119ffe9554feb2b8143072ae2223c4_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">有一系列选项可以进行子树的设置（下图1），大家可以自行探索。</p></div><div><p dir="auto">我们可以发现 MEGA 自带的绘图功能也很强大，可以达到很美观的效果，设置 clade 后如下图2所示。</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-929f801f4a22aec2715007086f63a4a4_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-9ae4271d6fac90e398c29096eede8a59_b.jpg" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.1.6 树的保存与导出**" dir="auto" class="heading" id="**4.1.6_树的保存与导出**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.1.6 树的保存与导出</strong></h3><div class="heading-children"><div><ul>
<li data-line="0" dir="auto">如果<strong>不需要对树进行进一步编辑</strong>，可以直接导出 MEGA 制作的进化树图片，选择 Image，可以保存为各种格式的图片文件。</li>
</ul></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-b9ec4b0442443d7d8a970ff76eef74c0_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">如果想要将进化树数据导出，<strong>在其它软件中编辑</strong>，我们可以选择 File -&gt; Export Current Tree(Newick)（下图1） -&gt; 勾选两个选项，即同时<strong>导出枝长与自举值</strong>（下图2），接着会出现<code>.nwk</code>格式文件的编辑窗口（下图3），直接点击保存然后命名为想要的名字即可。我这里保存为<code>example.nwk</code>等待步骤5使用。<br>
<strong>Newick格式</strong>是计算机可读形式的树文件标准格式，与 NEXUS、Phylip 等均是较为常见的储存系统发育树及其节点和分支相关数据的文件格式。我们通过MEGA得到树文件后，将其导出为 Newick 格式的树文件，然后可以使用 ggtree 等进行可视化。<br>
</li>
</ul></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-8180757ac89d558d4a3841b0f749b428_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-fb80355a366b16e7cbed25f757247812_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-b754180b1096cd17bb43dd0e9cac48ed_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">我们也可以保存一份<strong>树文件</strong>，等待下一次使用MEGA时继续编辑，只需要点击 File -&gt; Save Current Session -&gt; 然后保存为 <code>.mtsx</code>或者<code>.mts</code>格式的文件即可。</li>
</ul></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.2 构建 ML 树**" dir="auto" class="heading" id="**4.2_构建_ML_树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.2 构建 ML 树</strong></h3><div class="heading-children"><div><p dir="auto">最大似然法(Maximum Likelihood,ML)也是使用得比较普遍的一种进化树构建方法。因此我这里也介绍一下如何用MEGA构建MJ树。</p></div><div><p dir="auto"><strong>最大似然法基本介绍：</strong></p></div><div><p dir="auto">最大似然法是一种基于进化模型和位点信息的树构建方法，其理论基础是基于两条基本假设：不同的性状进化是独立的、物种发生分歧后进化独立。</p></div><div><p dir="auto">在ML法中，以一个特定的替代模型分析既定的一组序列数据，使所获得的每一个拓扑结构的似然率均为最大，挑出其最大似然率的最大拓扑结构为最终树。其主要优点是如果进化模型选择合理，ML树与真实进化的吻合度最高。然而，ML树的缺点在于计算强度大，非常耗时。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.2.1 选择最佳模型**" dir="auto" class="heading" id="**4.2.1_选择最佳模型**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.2.1 选择最佳模型</strong></h3><div class="heading-children"><div><p dir="auto">我们先看一下MEGA中估计ML树的参数，选择 PHYLOGENY -&gt; Construct/Test Maximum Parsimony Tree(s) -&gt; 可以进入参数设置页面，可以看到在 Model/Method 中提供了可以6个模型选项，Rates among sites提供了4个选项。</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-c80bf3591814b120df0a74b3ec7f07a0_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-04eff9fdc7c011579a5183cda2f52f38_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">接着我可以们直接使用MEGA软件预测一个适合我们数据的上述两个参数的最佳组合。我们依次点击：MODELS -&gt; Find Best DNA/Protein Models (ML)… -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件 -&gt; 参数设置页面不需要更改（如下图1），点击OK后一段时间会出现一个模型预测结果的窗口（如下图2）。</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-48fb2ebc9fbd403abc6a1ae42284acc4_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-78d75a47237a815702ec45eee34d8314_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">上图中红色框区域为MEGA为我们找到的模型结果，绿色框区域有一个对该结果的介绍。我们主要关注前5列（蓝色框所示）。</p></div><div><ul>
<li data-line="0" dir="auto">Model：替换模型与Rates参数简称的组合，从上到下排序为最好到最差。如 K2+G+I，代表 Model/Method 参数选择 Kimura 2-parameter 模型；Rates among Sites参数选择 Gamma Distributed With Invariant Sites(G+I)。</li>
<li data-line="1" dir="auto">Paramaters：相应模型下必须要估计的参数的数量，在所有条件都相同的情况下，通常认为估计更少的参数会更好。这里的条件指的是用合适的模型来衡量（当然条件通常不相同）</li>
<li data-line="2" dir="auto">BIC、AICc、InL是三种方法计算出的分数，BIC分数计算采用的是贝叶斯信息准则(Bayesian Information Criterion)，分数越低代表模型越好，MEGA对Model列的排序就是基于BIC进行排序的。AICc分数计算采用的是校正后AIC信息准则(Akaike Information Criterion,correction)，分数越低代表模型越好。InL代表极大似然值(Maximum Likelihood value)，绝对值越低代表模型越好。</li>
</ul></div><div><p dir="auto"><strong>在本例中</strong>，虽然参数数量第一个模型组合比第二个模型组合大1，但其BIC、AICc、InL分数都是第一种模型组合更好一点，因此我们选择第一个组合（K2+G+I）。有时候第一个模型组合的BIC分数可能小于第二个模型组合，但是如果相差不大，且AIC、InL、参数数量都是第二个模型组合比较好的话，我们也可以考虑选择使用第二个模型组合。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**4.2.2 估计 ML 树**" dir="auto" class="heading" id="**4.2.2_估计_ML_树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>4.2.2 估计 ML 树</strong></h3><div class="heading-children"><div><p dir="auto">如下图1，依次点击：PHYLOGENY -&gt; Construct/Test Maximum Likelihood Tree -&gt; 选择步骤3.3多序列比对得到的<code>.meg</code>文件，设置参数如下图2所示。点击OK即可开始比对。</p></div><div><p dir="auto"><strong>关于参数的设置</strong></p></div><div><ul>
<li data-line="0" dir="auto">Bootstrap：注意估计 ML 树设置 Bootstrap 检验会很耗时（电脑不太好的话有时候MEGA程序还会卡住或者闪退）。<br>
</li>
<li data-line="2" dir="auto">Gaps/Missing Data Treatment与NJ树一致，其它参数我们直接选择默认即可，一般不需要修改。<br>
</li>
</ul></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-a0fcb1fe0365f0acc6ecc7860b0ad2d9_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-22796a588b4eadf33a8419db4f7d4c02_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">最后我们可以得到最大似然法估计出的进化树，如下图所示，左下角红色箭头处会显示该树的log似然值（该值比真实树的似然值肯定会差一些）。其它关于树在MEGA中的可视化与NJ树一致，可见步骤4.1.4-4.1.6</p></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-cec0c6f0e6abba48f65ad11f55cc7cce_b.jpg" referrerpolicy="no-referrer"></p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="**5.使用 ggtree 进行可视化**" dir="auto" class="heading" id="**5.使用_ggtree_进行可视化**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>5.使用 ggtree 进行可视化</strong></h2><div class="heading-children"><div><p dir="auto"><strong>前面</strong>步骤 4.1.6 我们得到了导出的 Newick 格式的树文件，接着就可以使用R包 treeio 处理以及 ggtree 进行美化了。可视化的部分并没有统一的规范，每个人的需求不同。建议有R语言与ggplot一定基础的同学去看一看Y叔的书《R实战：系统发育树的数据集成操作及可视化》，里面讲得很详细（了解ggplot2语法学起来会很快）。不想用R画图的同学可以借助一些软件如iTOL、Figtree等，或者直接使用前面介绍的MEGA中绘制出来的进化树图片。</p></div><div><p dir="auto"><strong>下面</strong>我仅简单介绍一下如何使用treeio以及ggtree进行简单绘图，而不深入探索高级绘图的细节。我们一步一步探索ggtree的绘图过程：</p></div><div><hr></div><div><p dir="auto">如果没有安装ggtree，treeio，tidytree，需要先安装：</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">if(!require("ggtree",quietly = T)) BiocManager::install("ggtree")
if(!require("tidytree",quietly = T)) BiocManager::install("tidytree")
if(!require("treeio",quietly = T)) BiocManager::install("treeio")
</code><button class="copy-code-button">复制</button></pre></div><div class="heading-wrapper"><h3 data-heading="**5.1 treeio与ggtree使用介绍与练习**" dir="auto" class="heading" id="**5.1_treeio与ggtree使用介绍与练习**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>5.1 treeio与ggtree使用介绍与练习</strong></h3><div class="heading-children"><div><p dir="auto">加载需要的包</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">library(treeio)
library(ggtree)
library(tidytree)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">导入Newick格式的进化树</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">tree &lt;- read.tree("example.nwk")
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">我们可以先看一下 read.tree() 函数读入树文件后储存的对象格式，phylo对象是储存系统发育数据常用的一种格式，系统发育分析中用到的大多数R包都依赖于phylo对象。</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">class(tree)

## [1] "phylo"
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">然后就可以使用ggtree画出最简单的树的拓扑结构了</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">ggtree(tree)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-9d273a5da83d3a7a235f5ed244a64ef8_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">接着我们使用geom_tiplab()给每个分类单元添加名称，其实ggtree与ggplot函数的语法基本是一致的，如果要掌握ggtree最好先去了解一下ggplot语法。</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">ggtree(tree)+
  geom_tiplab(size=1.5,color="purple") # size与color参数分别设置字体大小与颜色
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-1300a4c94a747ba0c61dcb38390789a2_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">我们前面画出的树中，其分支长度代表了物种实际的进化程度，因此可以使用geom_treescale()添加标尺，其中标尺x,y参数的设置只需要将整个图想象成第一象限的坐标轴，然后调整标尺的位置即可：</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">ggtree(tree)+
  geom_tiplab(size=1.5,color="purple")+
  geom_treescale(x=2,y=20)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-df6ad6d034c30fcd3b088728d5b9f971_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">前面的树不是很整齐，如果我们不需要体现分枝长度，只需要知道各分类单元属于哪个clade，那么可以设置 branch.length="none"参数去除分支长度，使树更加美观，layout参数可以指定树的布局方式。</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">ggtree(tree,branch.length = "none",layout="circular")+
  geom_tiplab(size=1.5,color="purple")
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-575c696918350dc2245d3c175e16fab0_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">这个phylo树对象在R语言中实际上是一个列表。前面画的矩形树图没有1个明显的根分支，我们可以给列表添加1个元素，即根分支的长度，我这里把长度设置为0.5，然后使用geom_rootedge()添加根分支图层</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">tree$root.edge &lt;- 0.5
ggtree(tree)+
  geom_tiplab(size=1.5,color="purple")+
  geom_rootedge()
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-16cf427497140fdf90eac53bc2f4789d_b.jpg" referrerpolicy="no-referrer"></p></div><div><hr></div><div><p dir="auto">接下来我们探索如何对各个分类单元进行分组，即设置clade。 在这之前我们先了解一下我们的树数据。因为phylo对象不容易直观理解，因此可以通过as_tibble()函数将phylo对象转换为tibble表格，与数据框差不多：</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">tree_tibble &lt;- as_tibble(tree)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">我们打开 tree_tibble 看一下就可以发现数据其实很简单，只有4列数据，node列保存了分类单元所在的节点编号，parent列保存了其父节点的编号，branch.length列保存了分支长度，label列保存了该节点对应的标签（叶节点的标签即分类单元的名称，内部节点的标签即自展值），关于节点、分支、分类单元等概念忘记的可以去步骤 4.1.4 进行回顾。</p></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-5dcf02c2ecb43aa28a25377a8597cefe_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">因为每个节点都有一个编号或者标签，因此我们可以通过该编号定位到某个节点。这样就可以实现对不同 clade 进行分类、标注颜色等操作。比如说下图中红色和蓝色圆圈所在的节点下所有分类单元分别可以被归为clade1与 clade2，我们只要往tree数据中添加基于此的分组信息即可方便地使用ggtree进行分组标记颜色与注释clade。</p></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-172dc2ef88f5d2eecfcf743eb459701c_b.jpg" referrerpolicy="no-referrer"></p></div><div><hr></div><div><p dir="auto">我们先看一下可以提取节点信息的几个函数，对于tree这个phylo对象的数据，parent()函数返回了第1个节点的父节点的节点编号</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">parent(tree,1)

## [1] 26
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">相应的还有child()函数可以提取某个节点子节点的编号，</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">child(tree,26)

## [1] 1 2
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">ancestor()函数提取某个节点所有父辈节点编号，直到追溯到根节点</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">ancestor(tree,1)

## [1] 26 25 24 23 22 21 20
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">offspring()函数提取某个节点所有子代节点编号</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">offspring(tree,20)

##  [1] 21 31 19 22 11 23 28 24 27 25  4 26  3  1  2  5  6  7 29  8 30  9 10 12 32
## [26] 33 35 34 15 13 14 16 36 17 18
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">sibling()函数返回某个节点的兄弟节点</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">sibling(tree,1)

## [1] 2
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">上述函数也可以针对前面转换的tibble数据进行提取，可以得到更全的信息，比如：</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">child(tree_tibble,26)

## # A tibble: 2 × 4
##   parent  node branch.length label     
##    &lt;int&gt; &lt;int&gt;         &lt;dbl&gt; &lt;chr&gt;     
## 1     26     1       0.0102  MT268280.1
## 2     26     2       0.00610 FJ548853.1
</code><button class="copy-code-button">复制</button></pre></div><div><hr></div><div><p dir="auto"><strong>回到</strong>前面讲的，我们的目的是获取红蓝色圈对应的节点编号，以实现分类，因此我们只需要找到根节点编号，然后根据根节点编号获取其两个子节点编号就是我们相要的两个节点编号。</p></div><div><ul>
<li data-line="0" dir="auto">有一种比较简单的方法，先将所有节点编号显示在图中，然后我们从图中找到直接用于后面的输入，使用geom_nodelab()函数映射节点编号即可，可以发现我们想要的编号是21与31：</li>
</ul></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">ggtree(tree,branch.length = "none")+geom_nodelab(aes(label=node))
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-e4a446eb7ac441dfc49920a5ea3f6c10_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">还有一种方法是直接提取，我们首先通过<code>ancestor(tree,1)</code>得到任意节点（这里选择了节点1）的所有祖先节点，它返回的编号顺序是一级一级往前推的，因此最后一个编号就是根节点编号，然后通过<code>rev()</code>函数反向，再取其第一个编号就是根节点编号了。</li>
</ul></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">( node_root &lt;- rev(ancestor(tree,1))[1] )

## [1] 20
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">然后我们只需要使用<code>child()</code>函数即可得到想要的节点编号，示例的进化树中根节点分出了3个节点，前两个就是我们想要用于分组的节点。</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">( node &lt;- child(tree,node_root) )

## [1] 21 31 19
</code><button class="copy-code-button">复制</button></pre></div><div><hr></div><div><p dir="auto"><strong>接着</strong>通过groupClade函数，我们可以给树添加分组信息，只需要传入我们想要分组的节点编号的向量即可。下面的例子中，groupClade函数把节点21的所有子节点分为一组，把节点31的所有子节点分为另一组，转换为tibble数据查看一下，我们可以明显发现数据中添加了1列group信息，1代表第1组，2代表第2组，如果有别的节点不包含在我们输入的节点的子节点中，该函数会默认将这些节点标记为另外一组0。（需要注意groupClade只能对内部节点进行分组，想要将叶节点进行分组可以使用groupOTU函数）</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">groupClade(tree,c(21,31)) %&gt;% as_tibble()

## # A tibble: 36 × 5
##    parent  node branch.length label       group
##     &lt;int&gt; &lt;int&gt;         &lt;dbl&gt; &lt;chr&gt;       &lt;fct&gt;
##  1     26     1       0.0102  MT268280.1  1    
##  2     26     2       0.00610 FJ548853.1  1    
##  3     25     3       0.00733 OQ883907.1  1    
##  4     24     4       0.00288 OQ357724.1  1    
##  5     27     5       0       NC_038291.1 1    
##  6     27     6       0.00921 AF331831.1  1    
##  7     28     7       0.0821  JN660150.1  1    
##  8     29     8       0.0547  MW803134.1  1    
##  9     30     9       0.0601  MZ416787.1  1    
## 10     30    10       0.0816  JN654459.1  1    
## # ℹ 26 more rows
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">分组以后我们需要将其保存为一个新的tree变量才可以进一步画图，这里保存为tree2。</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">tree2 &lt;- groupClade(tree,c(21,31))
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">接着我们只需要使用ggplot2语法，使用aes函数将group分组信息映射到图中即可</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">p &lt;- ggtree(tree2,aes(color=group))+
  geom_tiplab()
p
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-2820c9a3ff46db89b357bd6bc80b3b1d_b.jpg" referrerpolicy="no-referrer"></p></div><div><hr></div><div><p dir="auto">接下来我们要进一步在分类单元右边添加clade标注。先构建一个数据框，node中还是填入刚才用于分类的编号形成的向量，name中填入对应的clade名称组成的向量，比如我想把节点21所在的分类命名为L1，把节点31所在的分类命名为L2,可以这样设置：</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">dat &lt;- data.frame(node=c(21,31),
                  name=c("L1","L2"))
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto">然后使用geom_cladelab函数添加一个图层，将前面制造的dat数据映射上去即可，offset参数代表设置文本到条带之间的距离。</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">p+geom_cladelab(data = dat,
                mapping = aes(node=node,label=name),
                offset=0.5)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-2e8b0f9b8ff313dbe1bbb8714bfe810e_b.jpg" referrerpolicy="no-referrer"></p></div><div><hr></div><div><p dir="auto">如果我们想要移除某个分类单元怎么办呢？比如我现在不想NC_001639.1出现在图中，只需要使用drop.tip函数传入需要移除的分类单元名称组成的向量即可，然后对新的树tree3绘图。</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">tree3 &lt;- drop.tip(tree2,"NC_001639.1")
ggtree(tree3)+
  geom_tiplab()+
  geom_cladelab(data = dat,
                mapping = aes(node=node,label=name),
                offset=0.5)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-9a7dc7ef208fb95742878930f1e33548_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><strong>接下来</strong>，如果我们只想给其中几个分类单元标上颜色，只需要映射想要标记颜色的分类单元到颜色参数即可。</p></div><div><ul>
<li data-line="0" dir="auto">可以直接映射分类单元名称</li>
</ul></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">mark &lt;- c("MT268280.1","JN660150.1","OQ803248.1")
ggtree(tree3,aes(color=label %in% mark))+
  geom_tiplab()+
  geom_cladelab(data = dat,
                mapping = aes(node=node,label=name),
                offset=0.5)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic4.zhimg.com/v2-1c4a808e4483e209b62753ad83f02cbf_b.jpg" referrerpolicy="no-referrer"></p></div><div><ul>
<li data-line="0" dir="auto">也可以映射分类单元的节点编号：</li>
</ul></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">ggtree(tree)+
  geom_tiplab(size=2,aes(color=node %in% c(1,7,14)))
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-2f0d8d3ec56ea7c4b979b4c2cd6b8015_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><strong>另外</strong>treeio也可以提取某个子树进行画图，比如我现在只想要L1所对应的子树，只需要使用subtree函数对子树进行提取即可。node参数指定要提取的子树的某个叶节点的编号或者标签均可以，levels_back参数指定子集树应该包括多少从选定节点返回的节点（即叶节点往前追溯多少数量的节点）</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">tree4 &lt;- tree_subset(tree,node=1,levels_back = 6)
ggtree(tree4)+
  geom_tiplab(size=2,color="purple")
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-043c281858e62db505ce0a26ab249409_b.jpg" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**5.2 进化树的可视化实践**" dir="auto" class="heading" id="**5.2_进化树的可视化实践**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>5.2 进化树的可视化实践</strong></h3><div class="heading-children"><div><p dir="auto">一、下面我展示了我自己画出来的一个进化树</p></div><div><pre class="language-rconsole" tabindex="0"><code class="language-rconsole is-loaded"># 载入包
library(treeio)
library(ggtree)
library(tidytree)

#导入树文件
tree &lt;- read.tree("example.nwk")
tree &lt;- drop.tip(tree,"NC_001639.1") # 移除不需要展示的分类单元
#设置根分支长度
tree$root.edge &lt;- 0.3
#获取分类节点编号
tree_tibble &lt;- as_tibble(tree)
node_root &lt;- rev(ancestor(tree,1))[1] #获取根节点编号
node &lt;- child(tree,node_root)[-3] #获取分类节点编号
tree2 &lt;- groupClade(tree,node)

#定义clade名称
dat &lt;- data.frame(node=node,
                  name=c("L1","L2"))
#ggtree可视化
p &lt;- ggtree(tree2,
       aes(color=group), #映射分组信息
       branch.length = "none",
       size=1)+ #分支粗细
     geom_tiplab(size=3,color="purple",offset = 0.2)+ #叶节点字体大小与颜色
     geom_tippoint(size=2)+ #给叶节点添加圆点
     geom_cladelab(data = dat, #添加clade分类数据
                   mapping = aes(node=node,label=name),
                   offset=1, #线条与分类单元文本之间的距离
                   offset.text=0.02, #线条与clade文本之间的距离
                   geom="label", #为clade文本添加背景
                   fill="lightblue", #clade文本背景颜色
                   fontsize=3.5, #clade文本字体大小
                   barsize=0.7, #线条粗细,align参数即是否对齐
                   align=T,
                   barcolor="grey")+#线条颜色
     geom_rootedge()+ #添加根分支图层
     theme_tree("#FEE4E9")+ #设置主题
     theme(legend.position = "none") #去除图例
p

#保存进化树图片
ggsave(p,file="plot1.png",width = 8,height = 12)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic1.zhimg.com/v2-945173fc8c08dfdba507a60d9202db10_b.jpg" referrerpolicy="no-referrer"></p></div><div><hr></div><div><p dir="auto">在得到上面的树后，如果我们想要调换某个分支的展示顺序，只需要简单地通过rotate函数即可完成，比如我对上图的节点20对应的分支调换展示顺序：</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">rotate(p,20)
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic3.zhimg.com/v2-616a9c36cbcc2013845e34d1c8a5de66_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">二、我们还可以将进化树结果与多序列比对结果放在同一张图中进行展示，多序列比对结果（example.fas）我们已经从步骤3.3得到</p></div><div><pre class="language-text" tabindex="0"><code class="language-text is-loaded">#载入需要的包
library(treeio)
library(ggtree)
library(tidytree)

#导入Newick树文件与多序列比对FASTA文件
tree &lt;- read.tree("example.nwk")
msa &lt;- read.fasta("example.fas")

#因为read.fasta函数导入多序列比对结果后_会识别为空格，因此需要先将空格转换为_，否则会导致无法与进化树的分类单元名匹配而绘图失败。
library(stringr)
names(msa) &lt;- str_replace(names(msa)," ","_")

#先绘制进化树
p1 &lt;- ggtree(tree,branch.length = "none")+geom_tiplab(size=2)

#然后用msaplot函数将两个结果绘制在一起
msaplot(p1,msa,
        offset = 3,width = 2) # offset为多序列比对结果与进化树之间的距离
</code><button class="copy-code-button">复制</button></pre></div><div><p dir="auto"><img src="https://pic2.zhimg.com/v2-bedad01b14de2bfed5fea90977a308dd_b.jpg" referrerpolicy="no-referrer"></p></div><div><p dir="auto">最后，进化树的可视化就完成了，上面只展示了一部分比较基础的绘图方法，想要继续绘制更多高级的好看的图形还是需要自己去看书学习。</p></div><div class="mod-footer"></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#MEGA多序列比对及建树（NJ）"><div class="tree-item-contents heading-link" heading-name="MEGA多序列比对及建树（NJ）"><span class="tree-item-title">MEGA多序列比对及建树（NJ）</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**3.1_导入待比对的_fasta_序列**"><div class="tree-item-contents heading-link" heading-name="**3.1 导入待比对的 fasta 序列**"><span class="tree-item-title"><strong>3.1 导入待比对的 fasta 序列</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**3.2_多序列比对**"><div class="tree-item-contents heading-link" heading-name="**3.2 多序列比对**"><span class="tree-item-title"><strong>3.2 多序列比对</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**3.3_保存比对结果**"><div class="tree-item-contents heading-link" heading-name="**3.3 保存比对结果**"><span class="tree-item-title"><strong>3.3 保存比对结果</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**3.4_比对结果可靠性检验**"><div class="tree-item-contents heading-link" heading-name="**3.4 比对结果可靠性检验**"><span class="tree-item-title"><strong>3.4 比对结果可靠性检验</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4._构建进化树**"><div class="tree-item-contents heading-link" heading-name="**4. 构建进化树**"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><strong>4. 构建进化树</strong></span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.1_构建_NJ_树**"><div class="tree-item-contents heading-link" heading-name="**4.1 构建 NJ 树**"><span class="tree-item-title"><strong>4.1 构建 NJ 树</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.1.1_检验是否适合构建NJ树**"><div class="tree-item-contents heading-link" heading-name="**4.1.1 检验是否适合构建NJ树**"><span class="tree-item-title"><strong>4.1.1 检验是否适合构建NJ树</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.1.2_NJ_树的估计-理论**"><div class="tree-item-contents heading-link" heading-name="**4.1.2 NJ 树的估计-理论**"><span class="tree-item-title"><strong>4.1.2 NJ 树的估计-理论</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.1.3_NJ_树的估计-实践**"><div class="tree-item-contents heading-link" heading-name="**4.1.3 NJ 树的估计-实践**"><span class="tree-item-title"><strong>4.1.3 NJ 树的估计-实践</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.1.4_树的认识与MEGA中的可视化**"><div class="tree-item-contents heading-link" heading-name="**4.1.4 树的认识与MEGA中的可视化**"><span class="tree-item-title"><strong>4.1.4 树的认识与MEGA中的可视化</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.1.5_绘制有根树**"><div class="tree-item-contents heading-link" heading-name="**4.1.5 绘制有根树**"><span class="tree-item-title"><strong>4.1.5 绘制有根树</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.1.6_树的保存与导出**"><div class="tree-item-contents heading-link" heading-name="**4.1.6 树的保存与导出**"><span class="tree-item-title"><strong>4.1.6 树的保存与导出</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.2_构建_ML_树**"><div class="tree-item-contents heading-link" heading-name="**4.2 构建 ML 树**"><span class="tree-item-title"><strong>4.2 构建 ML 树</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.2.1_选择最佳模型**"><div class="tree-item-contents heading-link" heading-name="**4.2.1 选择最佳模型**"><span class="tree-item-title"><strong>4.2.1 选择最佳模型</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**4.2.2_估计_ML_树**"><div class="tree-item-contents heading-link" heading-name="**4.2.2 估计 ML 树**"><span class="tree-item-title"><strong>4.2.2 估计 ML 树</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**5.使用_ggtree_进行可视化**"><div class="tree-item-contents heading-link" heading-name="**5.使用 ggtree 进行可视化**"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title"><strong>5.使用 ggtree 进行可视化</strong></span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**5.1_treeio与ggtree使用介绍与练习**"><div class="tree-item-contents heading-link" heading-name="**5.1 treeio与ggtree使用介绍与练习**"><span class="tree-item-title"><strong>5.1 treeio与ggtree使用介绍与练习</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="软件操作\分析原理\mega多序列比对及建树（nj）.html#**5.2_进化树的可视化实践**"><div class="tree-item-contents heading-link" heading-name="**5.2 进化树的可视化实践**"><span class="tree-item-title"><strong>5.2 进化树的可视化实践</strong></span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>